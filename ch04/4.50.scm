(define (analyze exp)
  (cond ((self-evaluating? exp) (analyze-self-evaluating exp))
        ...
        ((amb? exp)             (analyze-amb exp))
        ((ramb? exp)            (analyze-ramb exp))
        ...
        ))

(define (ramb? exp) (tagged-list? exp 'ramb))
(define (shuffle items)
  (define (nth things position)
    (define (iter ths i)
      (cond ((> i position) (error "index > capacity")) 
            ((= i position) (car ths))
            (else (iter (cdr ths) (+ i 1)))))
    (iter things 1))
  (define (before things position)
    (define (iter ths i result)
      (cond ((= i (- position 1)) (append (list (car ths)) result))
            (else (iter (cdr ths) (+ i 1) (append (list (car ths)) result)))))
    (cond ((> position (length things)) (error "index out of bounds:" things position))
          ((= position 1) '())
          (else (iter things 1 '()))))
  (define (after things position)
    (define (iter ths i)
      (cond ((= i (+ position 1)) ths)
            (else (iter (cdr ths) (+ i 1)))))
    (if (> position (length things))
        (error "index out of bounds:" things position)
        (iter things 1)))
  (cond ((null? items) '())
        ((= (length items) 1) items)
        (else
         (let ((first-elem-number (+ (random (length items)) 1)))
           (cons (nth items first-elem-number)
                 (shuffle (append (before items first-elem-number)
                                  (after items first-elem-number))))))))
(define (ramb-choices exp)
  (let ((choices (cdr exp)))
    (shuffle choices)))
(define (analyze-ramb exp) ;;identical to analyze-amb, but use ramb-choices
  (lambda (env succeed fail)
    (let ((cprocs (map analyze (ramb-choices exp))))
      (define (try-next choises)
        (if (null? choises)
            (fail)
            ((car choises)
             env
             succeed
             (lambda () (try-next (cdr choises))))))
      (try-next cprocs))))