(define (distinct? items)
  (cond ((null? items) true)
        ((null? (cdr items)) true)
        ((member (car items) (cdr items)) false)
        (else (distinct? (cdr items)))))

(define (multiple-dwelling)
  (let ((baker    (list 1 2 3 4 5))
        (cooper   (list 1 2 3 4 5))
        (fletcher (list 1 2 3 4 5))
        (miller   (list 1 2 3 4 5))
        (smith    (list 1 2 3 4 5)))

    (define (get-baker comb) (car comb))
    (define (get-cooper comb) (cadr comb))
    (define (get-fletcher comb) (caddr comb))
    (define (get-miller comb) (cadddr comb))
    (define (get-smith comb) (cadr (cdddr comb)))

    (filter (lambda (comb)
              (and (not (= (get-baker comb) 5))
                   (not (= (get-cooper comb) 1))
                   (not (= (get-fletcher comb) 5))
                   (not (= (get-fletcher comb) 1))
                   (> (get-miller comb) (get-cooper comb))
                   (not (= (abs (- (get-smith comb) (get-fletcher comb))) 1))
                   (not (= (abs (- (get-fletcher comb) (get-cooper comb))) 1))
                   (distinct? comb)))
            (combinations (list baker cooper fletcher miller smith)))))

(define (combinations item-lists)
  (if (null? item-lists)
      '()
      (let ((first-list (car item-lists))
            (rest-lists (cdr item-lists)))
        (cond ((null? first-list) '())
              ((null? rest-lists) (map (lambda (el) (list el)) first-list))
              (else (append (map (lambda (l) (cons (car first-list) l)) (combinations rest-lists))
                            (combinations (cons (cdr first-list) rest-lists))))))))
